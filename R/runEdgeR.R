#' Test for differential abundance using edgeR
#'
#' Test differential abundance of entities using functions from the
#' \code{\link{edgeR}} (Robinson et al. 2010, \emph{Bioinformatics}; McCarthy et
#' al. 2012, \emph{Nucleic Acids Research}) to fit models and calculate
#' moderated test for each entity. We have used
#' \code{\link[edgeR]{estimateDisp}} to estimate the dispersion. The
#' statistical methods implemented in the \code{edgeR} package were originally
#' designed for the analysis of gene expression data such as RNA-sequencing
#' counts. Here, we apply these methods to counts that might be from microbes or
#' cells.
#'
#' The experimental design must be specified using a design matrix. The
#' customized design matrix could be given by \code{design}.
#'
#' Normalization for samples is automatically performed by \code{edgeR} package.
#' More details about the calculation of normalization factor could be found
#' from \code{\link[edgeR]{calcNormFactors}}. A sample might include entities
#' corresponding to leaf nodes and internal nodes of tree. Only entities
#' corresponding to leaf nodes are used to calculate the library size of each
#' sample. The reason is that the abundance of an entity, corresponding to an
#' internal node, is calculated by taking sum of the abundance from its
#' descendant leaf nodes.
#'
#' @param tse A TreeSummarizedExperiment object.
#' @param onRow A logical value, TRUE or FALSE. If TRUE (default), the columns
#'   of the \code{assays} tables are treated as samples, and rows as entities
#'   (e.g. genes); otherwise, the other way around.
#' @param design A numeric matrix. It must be of full column rank. Defaults to
#'   use all columns of sample annotation data to create the design matrix. The
#'   sample annotation data is stored in the \code{colData} of \code{tse} when
#'   \code{onRow = TRUE}; otherwise it is in the \code{rowData}. Note: Users
#'   should check whether the default created design matrix is exactly what they
#'   want or create their own design matrix using
#'   \code{\link[stats]{model.matrix}}.
#' @param contrast A numeric vector specifying one contrast of
#'   the linear model coefficients to be tested equal to zero. Its length
#'   must equal to the number of columns of design. If NULL, the last
#'   coefficient will be tested equal to zero.
#' @param normalize A logical value, TRUE or FALSE. The default is TRUE.
#' @param method Normalization method to be used. See
#'   \code{\link[edgeR]{calcNormFactors}} for more details.
#' @param prior.count average prior count to be added to observation to shrink
#'   the estimated log-fold-changes towards zero. See \code{prior.count} in
#'   \code{\link[edgeR]{glmFit}}
#' @param assayNum A numeric vector. It specifies which matrix-like elements
#'   in assays will be used to do analysis. If NULL, the first one is used.
#' @param adjust.method A character string stating the method used to adjust
#'   p-values for multiple testing, passed on to \code{\link[stats]{p.adjust}}.
#'   It could be "bonferroni", "holm", "hochberg", "hommel", "BH", or "BY".
#'
#'
#' @import TreeSummarizedExperiment
#' @importFrom edgeR DGEList calcNormFactors estimateDisp glmFit glmLRT
#'   topTags
#' @importFrom methods is
#' @importFrom SummarizedExperiment assays colData rowData
#' @export
#' @return A data frame
#' \item{assays}{A list of tables}
#' \item{rowData}{It stores the information of rows in \code{assays}, and the
#' tables extracted from a \code{DGELRT} object that is generated by
#' \code{\link[edgeR:glmFit]{glmLRT}}. The later is stored as the internal part
#' of the \code{rowData}. More details or example could be found in the vignette
#' \code{Example of data analysis}}
#' \item{colData}{NULL}
#' \item{metadata}{
#'    \itemize{
#'    \item \code{assayNum} which elements in the \code{assays} have been
#'    used to run differential abundance analysis.
#'    \item \code{design} the design matrix as input.
#'    \item \code{contrast} the contrast vector as input.
#'    \item \code{output_glmFit} the output from \code{\link[edgeR]{glmFit}}. A
#'    object of \code{\link[edgeR]{DGEGLM-class}}
#'    }
#' }
#' @examples
#'
#' library(TreeSummarizedExperiment)
#' set.seed(1)
#' count <- matrix(rnbinom(300,size=1,mu=10),nrow=10)
#' colnames(count) <- paste(rep(LETTERS[1:3], each = 10), rep(1:10,3), sep = "_")
#' rownames(count) <- tinyTree$tip.label
#' count[1, ] <- 0
#' rowInf <- DataFrame(var1 = sample(letters[1:3], 10, replace = TRUE),
#'                     var2 = sample(c(TRUE, FALSE), 10, replace = TRUE))
#' colInf <- DataFrame(gg = factor(sample(1:3, 30, replace = TRUE)),
#'                     group = rep(LETTERS[1:3], each = 10))
#' lse <- TreeSummarizedExperiment(assays = list(count),
#'                                 rowData = rowInf,
#'                                 colData = colInf,
#'                                 rowTree = tinyTree)
#'
#' tse <- aggData(x = lse, onRow = TRUE)
#'
#' out <- runEdgeR(tse = tse, onRow = TRUE)
#'
#'
#'
runEdgeR <- function(tse, onRow = TRUE, design = NULL, 
                     contrast = NULL,
                     normalize = TRUE, method = "TMM",
                     adjust.method = "BH", 
                     prior.count = 0.125,
                     assayNum = NULL, 
                     filter = FALSE,
                     group_column = "group") {

    # The input data should be a TreeSummarizedExperiment object
    # It should includes only data on the leaf nodes
    if (!is(tse, "TreeSummarizedExperiment")) {
        stop("tse should be a TreeSummarizedExperiment.")
    }

    # If not specified, the first table in the assays is used
    if (is.null(assayNum)) {
        assayNum <- 1
    }


    # analysis step
    if (onRow) {
        # the count table
        count <- assays(tse)[[assayNum]]

        # extract link data
        ld <- rowLinks(tse)
        
        # add rownames
        rownames(ld) <- rownames(count) <- ld$nodeLab_alias
        
        
        # create design matrix
        if (is.null(design)) {
            design <- .designMatrix(data = colData(tse))
        }

        # the sample size in the smaller group
        sz <- min(table(colData(tse)$group))
    } else {
        # the count table
        count <- t(assays(tse)[[assayNum]])

        # extract link data
        ld <- colLinks(tse)

        # create design matrix
        if (is.null(design)) {
            design <- .designMatrix(data = rowData(tse))
        }

        # the sample size in the smaller group
        sz <- min(table(rowData(tse)$group))
    }

    # create the DGEList
    libSize <- apply(count[ld$isLeaf, ], 2, sum)
    # if filter = TRUE, entities, which have the number of samples with zero value
    # above the number of samples in the smaller group, are filtered out.
    if (filter) {
        isZ <- apply(count, 1, function(x) {
            sum(x > 0) < sz
        })
        rowF <- rownames(count)[isZ]
        count <- count[!isZ, ]
        
    }
    y <- DGEList(count, remove.zeros = FALSE)
    y$samples$lib.size <- libSize
    
    
    # do normalisation
    if (normalize) {
        y <- calcNormFactors(y, method = method)
    }

    # estimate dispersion
    y <- estimateDisp(y, design = design)

    # build model
    fit <- glmFit(y, design = design, prior.count = prior.count)

    # extract results
    lrt <- glmLRT(fit, contrast = contrast)
    tt1 <- topTags(lrt, n = Inf, adjust.method = adjust.method,
                   sort.by = "none")$table
    tt2 <- tt1[rownames(count), ]

    if (filter) {
        if (sum(isZ)) {
            tt2c <- tt2[rep(1, sum(isZ)), ]
            rownames(tt2c) <- rowF
            tt2c[] <- NA
            tt2 <- rbind(tt2, tt2c)    
        }
        
    }
    # cbind with the link data
    tt3 <- cbind(ld, tt2[rownames(ld), ])

    return(tt3)
}



#' Create design matrix
#'
#' \code{.designMatrix} creates a design matrix by expanding factors to a set of
#' dummay variables and epanding interactions similarly.
#'
#'
#' \code{.designMatrix} creates a design matrix using the data extracted from
#' \code{data}. \code{cols} specifies the columns to extract.
#' \code{.designMatrix} is built on \code{\link[stats]{model.matrix}} with
#' \code{contrasts.arg = NULL}.
#'
#' @param data A \code{data.frame} or \code{DataFrame}.
#' @param cols A numeric vector. Specify columns to include in the design of
#' model matrix. Default is to include all columns.
#'
#' @importFrom stats model.matrix as.formula
#' @keywords internal
#' @return a matrix.

.designMatrix <- function(data, cols = NULL) {

    stopifnot(class(data) %in% c("data.frame", "DataFrame"))

    # if cols is null, use all columns.
    if (is.null(cols)) {
        cols <- seq_len(ncol(data))
    }

    # create design matrix
    terms <- colnames(data)[cols]

    formula <- as.formula(paste("~", paste(terms, collapse = " + ")))

    design <- model.matrix(formula, data = data)

    return(design)
}
